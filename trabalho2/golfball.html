<!DOCTYPE html>
<html>

  <head>

    <title>INF2610 - Rendering em Tempo Real: Deferred Shading</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8" />

    <link rel="icon" href="https://discoverthreejs.com/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="../js/vendor/highlight/styles/github-gist.css">
    <script src="../js/vendor/highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>    

    <link href="../styles/main.css" rel="stylesheet" type="text/css">

    <!--

      Include the main three.js script.

      The global variable THREE will be
      available for use in any scripts
      loaded after this one.

    -->

    <script src="../js/vendor/three/takahirox/three.js"></script>
    <!-- <script src="../js/vendor/three/three.js"></script> -->

    <!--
      
      Include all needed scripts.
      
      This must be included AFTER the three.js script as it
      needs to use the global THREE variable
      
    -->
    
    <script src="../js/vendor/three/WebGL.js"></script>
    <script src="../js/vendor/three/OrbitControls.js"></script>
    <script src="../js/vendor/three/dat.gui.min.js"></script>
    <script src="../js/vendor/three/GLTFLoader.js"></script>
    <script src="../js/vendor/three/MTLLoader.js"></script>
    <script src="../js/vendor/three/LoaderSupport.js"></script>
    <script src="../js/vendor/three/OBJLoader2.js"></script>
    <script src="../js/vendor/three/BufferGeometryUtils.js"></script>

  </head>

  <body>

    <div class="wrapper">

        <header class="header">
            <h1 class="title">Deferred Shading: Golf Ball</h1>
            <!-- <h2 class="title">Using TBN in vertex shader</h2> -->
        </header>
        <article class="main">
          <div id="scene-container">
            <!-- This div will hold our scene-->
          </div>
        </article>
        <aside class="aside aside-1">
            <h2 class="title">GBuffer Vertex Shader</h2>
          <pre>
            <code class="glsl" id="vertex-shader-code">
              VERTEX SHADER    
            </code>
          </pre>
  
        </aside>
        <aside class="aside aside-2">
          <h2 class="title">GBuffer Fragment Shader</h2>
          <pre>
            <code class="glsl" id="fragment-shader-code">
              FRAGMENT SHADER
            </code>
          </pre>
        </aside>
        <footer class="footer">
            <h4 class="title">INF2610 - Rendering em Tempo Real</h4>
        </footer>
  
    </div>

    <!-- Write to G-Buffer -->
    <script id="gvs" type="x-shader/x-vertex">
      #version 300 es

      struct PointLight {
        vec3 color;
        vec3 position;
        float distance; 
      };

      /**
        https://threejs.org/docs/index.html#api/en/renderers/webgl/WebGLProgram
        Uniforms injected by Three.js:
        - position: vertex position
        - uv: texture coordinates
        - projectionMatrix: project matrix
        - normalMatrix: normal matrix
        - modelViewMatrix: model view matrix
        - cameraPosition: camera position
      */

      // Point light array injected by Three.js
      uniform PointLight pointLights[NUM_POINT_LIGHTS];
      
      // Tangent generated by model loader OBJLoader2 
      attribute vec4 tangent;
      
      out vec2 vUv;                   // texture coordinates
      out vec3 fragPos;        // vertex position in tangent space
      out mat3 TBN;                   // Tangent Binormal Normal matrix
      out vec3 N;                     // normals
      out vec3 T;                     // tangents

      void main() 
      {
        
        // Generating binormal vector
        vec4 binormal = normalize( vec4( cross(normal, tangent.xyz), 0.0 ) );

        // Gerenating Inverted Tangent Binormal Normal matrix
        vec3 B;
        T = normalize(vec3(modelMatrix * tangent));
        B = normalize(vec3(modelMatrix * binormal));
        N = normalize(vec3(modelMatrix * vec4(normal, 0.0)));
        TBN = ( mat3(T, B, N) );
        
        // Position in world coordinates
        fragPos = vec3( modelMatrix * vec4(position, 1.0) );

        // Just repassing the texture coordinates
        vUv = uv;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
  </script>
  <script id="gfs" type="x-shader/x-fragment">
    #version 300 es

    precision highp float;
    precision highp int;

    struct PointLight {
      vec3 color;
      vec3 position;
      float distance; 
    };

    in vec4 color;                 // diffuse color
    in vec2 vUv;                   // texture coordinates
    in vec3 fragPos;               // vertex position
    in mat3 TBN;                   // Tangent Binormal Normal matrix
    in vec3 N;                     // normals
    in vec3 T;                     // tangents
    
    uniform vec4 ka;               // ambient color
    uniform vec4 kd;               // diffuse color
    uniform vec4 ks;               // specular color
    uniform float shi;             // shininess
    uniform sampler2D bumpTex;     // normal texture

    // Point light array injected by Three.js
    uniform PointLight pointLights[NUM_POINT_LIGHTS];

    // final color
    //layout(location=0) out vec4 out_FragColor;

    // GBuffer outputs
    layout(location=0) out vec4 gColor;
    layout(location=1) out vec3 gNormal;
    layout(location=2) out vec3 gBinormal;
    layout(location=3) out vec3 gTangent;
    layout(location=4) out vec3 gPosition;
    layout(location=5) out vec3 gCameraPos;
    layout(location=6) out vec3 gBumpMap;

    void main() 
    {
      // GBuffers outputs
      gColor = kd;
      gNormal = N;
      gTangent = T;
      gBinormal = normalize( cross(N,T) );
      gPosition = fragPos;
      gCameraPos = cameraPosition;
      gBumpMap = texture2D(bumpTex, vUv).xyz;

    #ifdef TRY_ON_GBUFFER_FS

      // Obtain normal from normal map in range [0,1]
      vec3 normalTex = texture2D(bumpTex, vUv).xyz;

      // Transform normal vector to range [-1,1]
      vec3 normal = normalize(-1.0 + 2.0*normalTex);

      // Normal in world space
      normal = normalize( TBN * normal );

      vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
      for(int i=0; i < NUM_POINT_LIGHTS; i++)
      {
        vec3 tanLightPos = pointLights[i].position;
        vec3 lightDir = normalize( tanLightPos - fragPos );

        // Compute lighting
        float NdotL = dot( lightDir, normal );

        // Calculate specular
        float spec = 0.0;
        if ( NdotL > 0.0 ) {
          vec3 viewDir = normalize( cameraPosition - fragPos );
          vec3 halfVector = normalize( lightDir + viewDir );
          spec = pow( max( dot( normal, halfVector ), 0.0 ), shi );
        }

        // diffuse color from light color
        float diff = max( NdotL, 0.0 );
        vec4 diffuse = diff * vec4(pointLights[i].color, 1.0);

        finalColor += kd*diffuse + ks*spec;
      }

      gColor = finalColor;
      #endif      

    }
  </script>
    
    <!-- Read G-Buffer and render to screen -->
    <script id="render-vert" type="x-shader/x-vertex">
    #version 300 es

      out vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
    </script>
    <script id="render-frag" type="x-shader/x-fragment">
      #version 300 es

      struct PointLight {
        vec3 color;
        vec3 position;
        float distance; 
      };

      // Point light array injected by Three.js
      uniform PointLight pointLights[NUM_POINT_LIGHTS];
      
      layout(location = 0) out vec4 out_FragColor;

      in vec2 vUv;

      uniform vec4 ka;               // ambient color
      uniform vec4 kd;               // diffuse color
      uniform vec4 ks;               // specular color
      uniform float shi;             // shininess

      uniform sampler2D tColor;
      uniform sampler2D tNormal;
      uniform sampler2D tBinormal;
      uniform sampler2D tTangent;
      uniform sampler2D tPosition;
      uniform sampler2D tCameraPos;
      uniform sampler2D tDepth;
      uniform sampler2D tBumpMap;

      void main() {

        vec3 T = normalize(texture2D(tTangent, vUv).xyz);
        vec3 B = normalize(texture2D(tBinormal, vUv).xyz);
        vec3 N = normalize(texture2D(tNormal, vUv).xyz);
        mat3 TBN = ( mat3(T, B, N) );

        vec3 fragPos = texture2D(tPosition, vUv).xyz;
        vec3 cameraPos = texture2D(tCameraPos, vUv).xyz;

        // Obtain normal from normal map in range [0,1]
        vec3 normalTex = texture2D(tBumpMap, vUv).xyz;
  
        // Transform normal vector to range [-1,1]
        vec3 normal = normalize(-1.0 + 2.0*normalTex);
        normal = TBN * normal;

        vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
        for(int i=0; i < NUM_POINT_LIGHTS; i++)
        {
          vec3 lightPos =  pointLights[i].position;
          vec3 lightDir = normalize( lightPos - fragPos );

          // Compute lighting
          float NdotL = dot( lightDir, normal );

          // Calculate specular
          float spec = 0.0;
          if ( NdotL > 0.0 ) {
            vec3 viewDir = normalize( cameraPos - fragPos );
            vec3 halfVector = normalize( lightDir + viewDir );
            spec = pow( max( dot( normal, halfVector ), 0.0 ), shi );
          }

          // diffuse color from light color
          float diff = max( NdotL, 0.0 );
          vec4 diffuse = diff * vec4(pointLights[i].color, 1.0);
  
          finalColor += kd*diffuse + ks*spec;
          
        }

        vec4 depth = texture2D(tDepth, vUv);
        vec4 color = texture2D(tColor, vUv);


        // final color      
        out_FragColor = ka + finalColor;
        //out_FragColor = vec4(normal, 1.0);

      }
    </script>

  <script id="vs-2" type="x-shader/x-vertex">
    #version 300 es

    struct PointLight {
      vec3 color;
      vec3 position;
      float distance; 
    };

    /**
      https://threejs.org/docs/index.html#api/en/renderers/webgl/WebGLProgram
      Uniforms injected by Three.js:
      - position: vertex position
      - uv: texture coordinates
      - projectionMatrix: project matrix
      - modelMatrix: model matrix
      - modelViewMatrix: model view matrix
      - cameraPosition: camera position
    */

    // Point light array injected by Three.js
    uniform PointLight pointLights[NUM_POINT_LIGHTS];
    
    // Tangent generated by model loader OBJLoader2 
    attribute vec4 tangent;
    
    out vec4 color;       // diffuse color
    out vec2 vUv;         // texture coordinates
    out vec3 dirLight[NUM_POINT_LIGHTS];    // light direction
    out vec3 halfVector[NUM_POINT_LIGHTS];  // vector between viewer and light
    out mat3 TBN;         // Tangent Binormal Normal matrix

    void main() 
    {

      // Generating binormal vector
      vec4 binormal = normalize( vec4( cross(normal, tangent.xyz), 0.0 ) );

      // Gerenating Tangent Binormal Normal matrix
      vec3 T = normalize(vec3(modelMatrix * tangent));
      vec3 B = normalize(vec3(modelMatrix * binormal));
      vec3 N = normalize(vec3(modelMatrix * vec4(normal,    0.0)));
      TBN = ( mat3(T, B, N) );

      for(int i=0; i < NUM_POINT_LIGHTS; i++)
      {
        // Getting light direction from the 1st point light
        dirLight[i] = pointLights[i].position - position;
        
        // Calculate half vector
        halfVector[i] = normalize( dirLight[i] + cameraPosition );
      }
      // Just repassing the texture coordinates
      vUv = uv;

      // Using white color as default color
      color = vec4(1.0);

      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  </script>
  <script id="fs-2" type="x-shader/x-fragment">
    #version 300 es

    precision highp float;
    precision highp int;

    struct PointLight {
      vec3 color;
      vec3 position;
      float distance; 
    };
    

    in vec4 color;              // diffuse color (not used)
    in vec2 vUv;                // texture coordinates
    in vec3 dirLight[NUM_POINT_LIGHTS];           // light direction 
    in vec3 halfVector[NUM_POINT_LIGHTS];         // vector between viewer and light
    in mat3 TBN;                // Tangent Binormal Normal matrix
    
    uniform vec4 ka;            // ambient color
    uniform vec4 kd;            // diffuse color
    uniform vec4 ks;            // specular color
    uniform float shi;          // shininess
    uniform sampler2D bumpTex;  // normal texture

    // Point light array injected by Three.js
    uniform PointLight pointLights[NUM_POINT_LIGHTS];

    // final color
    out vec4 out_FragColor;

    void main() 
    {
      
      // Obtain normal from normal map in range [0,1]
      vec3 normalTex = texture2D(bumpTex, vUv).xyz;

      // Transform normal vector to range [-1,1]
      vec3 normal = normalize(-1.0 + 2.0*normalTex);

      // Normal in world space
      normal = normalize( TBN * normal );

      vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
      for(int i=0; i < NUM_POINT_LIGHTS; i++)
      {
        vec3 light = normalize(dirLight[i]);
  
        // Compute lighting
        float NdotL = dot( normal, light );
        float diff = max( NdotL, 0.0 );
  
        // Calculate specular
        float spec = 0.0;
        if ( NdotL > 0.0 ) {
          vec3 halfv = normalize( halfVector[i] );
          spec = pow( max( dot( normal, halfv ), 0.0 ), shi/0.4);
        }
        
        // diffuse color from light color
        vec4 diffuse = diff * vec4(pointLights[i].color, 1.0);

        finalColor += kd*diffuse + ks*spec;
      }

      // final color
      out_FragColor = ka + finalColor;

    }
  </script>


    <!--
      Finally, include the script that
      runs your three.js app.
    -->

    <script src="js/app-golfball.js"></script>

  </body>

</html>