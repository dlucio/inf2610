<!DOCTYPE html>
<html>

  <head>

    <title>INF2610 - Rendering em Tempo Real: Deferred Shading</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8" />

    <link rel="icon" href="https://discoverthreejs.com/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="../js/vendor/highlight/styles/github-gist.css">
    <script src="../js/vendor/highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>    

    <link href="../styles/main.css" rel="stylesheet" type="text/css">

    <!--

      Include the main three.js script.

      The global variable THREE will be
      available for use in any scripts
      loaded after this one.

    -->

    <script src="../js/vendor/three/takahirox/three.js"></script>
    <!-- <script src="../js/vendor/three/three.js"></script> -->

    <!--
      
      Include all needed scripts.
      
      This must be included AFTER the three.js script as it
      needs to use the global THREE variable
      
    -->
    
    <script src="../js/vendor/three/WebGL.js"></script>
    <script src="../js/vendor/three/OrbitControls.js"></script>
    <script src="../js/vendor/three/dat.gui.min.js"></script>
    <script src="../js/vendor/three/GLTFLoader.js"></script>
    <script src="../js/vendor/three/MTLLoader.js"></script>
    <script src="../js/vendor/three/LoaderSupport.js"></script>
    <script src="../js/vendor/three/OBJLoader2.js"></script>
    <script src="../js/vendor/three/BufferGeometryUtils.js"></script>

  </head>

  <body>

    <div class="wrapper">

        <header class="header">
            <h1 class="title">Deferred Shading: Golf Ball</h1>
            <!-- <h2 class="title">Using TBN in vertex shader</h2> -->
            <div id="scene-container">
              <!-- This div will hold our scene-->
            </div>
        </header>
        <aside class="aside aside-1">
            <h2 class="title">G-Buffer Vertex Shader</h2>
          <pre>
            <code class="glsl" id="gbuffer-vertex-shader-code">
              G-BUFFER-VERTEX SHADER    
            </code>
          </pre>
        </aside>
        <aside class="aside aside-1">
          <h2 class="title">G-Buffer Fragment Shader</h2>
          <pre>
            <code class="glsl" id="gbuffer-fragment-shader-code">
              G-BUFFER-FRAGMENT SHADER
            </code>
          </pre>
        </aside>
        <aside class="aside aside-2">
            <h2 class="title">Lighting Vertex Shader</h2>
          <pre>
            <code class="glsl" id="lighting-vertex-shader-code">
              LIGHTING-VERTEX SHADER    
            </code>
          </pre>
        </aside>
        <aside class="aside aside-2">
          <h2 class="title">Lighting Fragment Shader</h2>
          <pre>
            <code class="glsl" id="lighting-fragment-shader-code">
              LIGHTING-FRAGMENT SHADER
            </code>
          </pre>
        </aside>
        <footer class="footer">
            <h4 class="title">INF2610 - Rendering em Tempo Real</h4>
        </footer>
  
    </div>

    <!-- Write to G-Buffer -->
    <script id="gvs" type="x-shader/x-vertex">
      #version 300 es

      /**
        https://threejs.org/docs/index.html#api/en/renderers/webgl/WebGLProgram
        Uniforms injected by Three.js:
        - position: vertex position
        - uv: texture coordinates
        - normal: vertex normal
        - projectionMatrix: project matrix
        - normalMatrix: normal matrix
        - modelViewMatrix: model view matrix
        - cameraPosition: camera position
      */

      // Tangent generated by model loader OBJLoader2 
      attribute vec4 tangent;
      
      out vec2 vUv;     // texture coordinates
      out vec3 fragPos; // vertex position
      out mat3 TBN;     // Tangent Binormal Normal matrix

      out vec3 vNormal;  // vertex normal

      void main() 
      {
        
        // Generating binormal vector
        vec4 binormal = normalize( vec4( cross(normal, tangent.xyz), 0.0 ) );

        // Gerenating Tangent Binormal Normal matrix
        vec3 T = normalize(vec3(modelMatrix * tangent));
        vec3 B = normalize(vec3(modelMatrix * binormal));
        vec3 N = normalize(vec3(modelMatrix * vec4(normal, 0.0)));
        TBN = ( mat3(T, B, N) );
        
        // Position in world coordinates
        fragPos = vec3( modelMatrix * vec4(position, 1.0) );

        // Just repassing the texture coordinates and vertex normals
        vUv = uv;
        vNormal = normal;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
  </script>
  <script id="gfs" type="x-shader/x-fragment">
    #version 300 es

    precision highp float;
    precision highp int;

    
    in vec4 color;                 // diffuse color
    in vec2 vUv;                   // texture coordinates
    in vec3 fragPos;               // vertex position
    in vec3 vNormal;               // vertex normal
    in mat3 TBN;                   // Tangent Binormal Normal matrix
    
    uniform vec4 kd;               // diffuse color
    uniform sampler2D bumpTex;     // normal texture

    // G-Buffer outputs
    layout(location=0) out vec4 gColor;     // vertex color
    layout(location=1) out vec3 gNormalMap; // normal map from bump texture
    layout(location=2) out vec3 gPosition;  // vertex position
    layout(location=3) out vec3 gNormal;    // vertex normal

    void main() 
    {
      // G-Buffers outputs
      gPosition = fragPos;
      
      // Obtain normal from normal map in range [0,1]
      vec3 normalTex = texture2D(bumpTex, vUv).xyz;
      gNormalMap = normalize(-1.0 + 2.0*normalTex);
      gNormalMap = normalize( TBN * gNormalMap );
      
      // G-Buffer output for debug
      gColor = kd;
      gNormal = vNormal;
    }
  </script>
    
    <!-- Read G-Buffer and render to screen -->
    <script id="render-vert" type="x-shader/x-vertex">
    #version 300 es

      out vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
    </script>
    <script id="render-frag" type="x-shader/x-fragment">
      #version 300 es

      struct PointLight {
        vec3 color;
        vec3 position;
        float distance; 
      };

      // Point light array injected by Three.js
      uniform PointLight pointLights[NUM_POINT_LIGHTS];
      
      layout(location = 0) out vec4 out_FragColor;

      in vec2 vUv;

      uniform vec4 ka;               // ambient color
      uniform vec4 kd;               // diffuse color
      uniform vec4 ks;               // specular color
      uniform float shi;             // shininess
      uniform vec3 cameraPos;        // gbuffer camera position
      uniform int gBufferToShow;     // show saved gbuffer 

      uniform sampler2D tColor;      // vertex color
      uniform sampler2D tNormalMap;  // normals from normal map texture
      uniform sampler2D tPosition;   // vertex position

      uniform sampler2D tNormal;     // vertex normal
      uniform sampler2D tDepth;      // depth buffer

      void main() {

        vec3 normal = texture2D(tNormalMap, vUv).xyz;
        vec3 fragPos = texture2D(tPosition, vUv).xyz;

        // Only for debug
        vec3 normalMapColor = normal;

        // Set normal from normal map in range [0,1]
        normal = normalize(-1.0 + 2.0*normal);

        vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
        for(int i=0; i < NUM_POINT_LIGHTS; i++)
        {
          vec3 lightPos =  pointLights[i].position;
          vec3 lightDir = normalize( lightPos - fragPos );

          // Compute lighting
          float NdotL = dot( lightDir, normal );

          // Calculate specular
          float spec = 0.0;
          if ( NdotL > 0.0 ) {
            vec3 viewDir = normalize( cameraPos - fragPos );
            vec3 halfVector = normalize( lightDir + viewDir );
            spec = pow( max( dot( normal, halfVector ), 0.0 ), shi );
          }

          // diffuse color from light color
          float diff = max( NdotL, 0.0 );
          vec4 diffuse = diff * vec4(pointLights[i].color, 1.0);
  
          finalColor += kd*diffuse + ks*spec;
          
        }

        // final color
        out_FragColor = ka + finalColor;

        // For debug: Textures from G-Buffer
        if (gBufferToShow == 1) 
        {
          // position
          out_FragColor = vec4(fragPos, 1.0);
        } 
        else if (gBufferToShow == 2) {
          // normal map
          out_FragColor = vec4(normalMapColor, 1.0);
        }
        else if (gBufferToShow == 3) {
          // vertex normal
          out_FragColor = vec4(texture2D(tNormal, vUv).rgb, 1.0);
        }
        else if (gBufferToShow == 4) {
          // vertex color
          out_FragColor = vec4(texture2D(tColor, vUv).rgb, 1.0);
        }
        else if (gBufferToShow == 5) {
          // depth
          vec4 depth = texture( tDepth, vUv ).rgba;
          out_FragColor = vec4(depth.r, depth.r, depth.r, 1.0);
        }

      }
    </script>

    <!--
      Finally, include the script that
      runs your three.js app.
    -->

    <script src="js/app-golfball.js"></script>

  </body>

</html>