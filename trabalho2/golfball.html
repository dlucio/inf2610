<!DOCTYPE html>
<html>

  <head>

    <title>INF2610 - Rendering em Tempo Real: Deferred Shading</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8" />

    <link rel="icon" href="https://discoverthreejs.com/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="../js/vendor/highlight/styles/github-gist.css">
    <script src="../js/vendor/highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>    

    <link href="../styles/main.css" rel="stylesheet" type="text/css">

    <!--

      Include the main three.js script.

      The global variable THREE will be
      available for use in any scripts
      loaded after this one.

    -->

    <script src="../js/vendor/three/takahirox/three.js"></script>
    <!-- <script src="../js/vendor/three/three.js"></script> -->

    <!--
      
      Include all needed scripts.
      
      This must be included AFTER the three.js script as it
      needs to use the global THREE variable
      
    -->
    
    <script src="../js/vendor/three/WebGL.js"></script>
    <script src="../js/vendor/three/OrbitControls.js"></script>
    <script src="../js/vendor/three/dat.gui.min.js"></script>
    <script src="../js/vendor/three/GLTFLoader.js"></script>
    <script src="../js/vendor/three/MTLLoader.js"></script>
    <script src="../js/vendor/three/LoaderSupport.js"></script>
    <script src="../js/vendor/three/OBJLoader2.js"></script>
    <script src="../js/vendor/three/BufferGeometryUtils.js"></script>

  </head>

  <body>

    <div class="wrapper">

        <header class="header">
            <h1 class="title">Deferred Shading: Golf Ball</h1>
            <!-- <h2 class="title">Using TBN in vertex shader</h2> -->
        </header>
        <article class="main">
          <div id="scene-container">
            <!-- This div will hold our scene-->
          </div>
        </article>
        <aside class="aside aside-1">
            <h2 class="title">Vertex Shader</h2>
          <pre>
            <code class="glsl" id="vertex-shader-code">
              VERTEX SHADER    
            </code>
          </pre>
  
        </aside>
        <aside class="aside aside-2">
          <h2 class="title">Fragment Shader</h2>
          <pre>
            <code class="glsl" id="fragment-shader-code">
              FRAGMENT SHADER
            </code>
          </pre>
        </aside>
        <footer class="footer">
            <h4 class="title">INF2610 - Rendering em Tempo Real</h4>
        </footer>
  
    </div>
    
    <!-- Write to G-Buffer -->
    <script id="gbuffer-vert" type="x-shader/x-vertex">
      #version 300 es

      out vec3 vNormal;
      out vec2 vUv;
      out vec4 vPosition;

      void main() {

        vUv = uv;

        vec3 transformedNormal = normalMatrix * normal;
        vNormal = normalize( transformedNormal );

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        vPosition = gl_Position;

      }
    </script>
    <script id="gbuffer-frag" type="x-shader/x-fragment">
      #version 300 es

      layout(location = 0) out vec4 gColor;
      layout(location = 1) out vec4 gNormal;
      layout(location = 2) out vec4 gPosition;

      uniform sampler2D bumpTex;

      in vec3 vNormal;
      in vec2 vUv;
      in vec4 vPosition;

      void main() {

        // write color to G-Buffer
        gColor = vec4(1.0, 1.0, 0.0, 1.0); //texture( bumpTex, vUv );
        
        // write normals to G-Buffer
        gNormal = vec4( normalize( vNormal ), 1.0 );
        
        // write position to G-Buffer
        gPosition = vPosition;
      }
    </script>

    <!-- Read G-Buffer and render to screen -->
    <script id="render-vert" type="x-shader/x-vertex">
    #version 300 es

      out vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
    </script>
    <script id="render-frag" type="x-shader/x-fragment">
      #version 300 es

      layout(location = 0) out vec4 pc_FragColor;

      in vec2 vUv;

      uniform sampler2D tDiffuse;
      uniform sampler2D tNormal;
      uniform sampler2D tPosition;
      uniform sampler2D tDepth;

      void main() {

        vec3 diffuse = texture( tDiffuse, vUv ).rgb;
        vec3 normal = texture( tNormal, vUv ).rgb;

        vec4 depth = texture( tDepth, vUv ).rgba;
        vec4 position = texture( tPosition, vUv ).rgba;

        pc_FragColor.rgb = mix( diffuse, normal, step( 0.5, vUv.x ) );
        pc_FragColor.a = 1.0;
        
        //pc_FragColor.rgb = diffuse.rgb;
        //pc_FragColor = position.rgba;
        //pc_FragColor = depth.rgba;
        //pc_FragColor.rgb = vec3(depth.r, depth.r, depth.r);
        //pc_FragColor = vec4(depth.r, depth.r, depth.r, 1.0);
        
        //pc_FragColor.rgb = vec3(0.0, 1.0, 0.0);

      }
    </script>

    <script id="vs" type="x-shader/x-vertex">
      #version 300 es

      struct PointLight {
        vec3 color;
        vec3 position;
        float distance; 
      };

      /**
        https://threejs.org/docs/index.html#api/en/renderers/webgl/WebGLProgram
        Uniforms injected by Three.js:
        - position: vertex position
        - uv: texture coordinates
        - projectionMatrix: project matrix
        - normalMatrix: normal matrix
        - modelViewMatrix: model view matrix
        - cameraPosition: camera position
      */

      // Point light array injected by Three.js
      uniform PointLight pointLights[NUM_POINT_LIGHTS];
      
      // Tangent generated by model loader OBJLoader2 
      attribute vec4 tangent;
      
      out vec4 color;                             // diffuse color
      out vec2 vUv;                               // texture coordinates
      out vec3 tangentLightPos[NUM_POINT_LIGHTS]; // light position in tangent space
      out vec3 tangentCameraPosition;             // camera position in tangent space
      out vec3 tangentFragPos;                    // vertex position in tangent space

      void main() 
      {
        
        // Gerenating Inverted Tangent Binormal Normal matrix
        vec3 T = normalize(vec3(normalMatrix * tangent.xyz));
        vec3 N = normalize(vec3(normalMatrix * normal));
        vec3 B = normalize( cross(N, T) );
        mat3 TBN = transpose( mat3(T, B, N) );
        
        // Position in world coordinates
        vec3 fragPos = vec3( modelMatrix * vec4(position, 1.0) );

        // To tangent space
        for(int i=0; i < NUM_POINT_LIGHTS; i++) 
        {
          tangentLightPos[i] = TBN * pointLights[i].position;
        }

        tangentCameraPosition = TBN * cameraPosition;
        tangentFragPos = TBN * fragPos;

        // Just repassing the texture coordinates
        vUv = uv;

        // Using white as default color
        color = vec4(1.0);

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
  </script>
  <script id="fs" type="x-shader/x-fragment">
    #version 300 es

    precision highp float;
    precision highp int;

    struct PointLight {
      vec3 color;
      vec3 position;
      float distance; 
    };

    in vec4 color;                            // diffuse color
    in vec2 vUv;                              // texture coordinates
    in vec3 tangentLightPos[NUM_POINT_LIGHTS];// light position in tangent space
    in vec3 tangentCameraPosition;            // camera position in tangent space
    in vec3 tangentFragPos;                   // vertex position in tangent space
    
    uniform vec4 ka;                          // ambient color
    uniform vec4 kd;                          // diffuse color
    uniform vec4 ks;                          // specular color
    uniform float shi;                        // shininess
    uniform sampler2D bumpTex;                // normal texture

    // Point light array injected by Three.js
    uniform PointLight pointLights[NUM_POINT_LIGHTS];

    // final color
    out vec4 out_FragColor;

    void main() 
    {
      
      // Obtain normal from normal map in range [0,1]
      vec3 normalTex = texture2D(bumpTex, vUv).xyz;

      // Transform normal vector to range [-1,1]
      vec3 normal = normalize(-1.0 + 2.0*normalTex);

      vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
      for(int i=0; i < NUM_POINT_LIGHTS; i++)
      {
        
        //vec4 color = pointLightColor[i];
        vec3 lightDir = normalize( tangentLightPos[i] - tangentFragPos );
  
        // Compute lighting
        float NdotL = dot( lightDir, normal );
        
        // Calculate specular
        float spec = 0.0;
        if ( NdotL > 0.0 ) {
          vec3 viewDir = normalize( tangentCameraPosition - tangentFragPos );
          vec3 halfVector = normalize( lightDir + viewDir );
          spec = pow( max( dot( normal, halfVector ), 0.0 ), shi );
        }
        
        // diffuse color from light color
        float diff = max( NdotL, 0.0 );
        vec4 diffuse = diff * vec4(pointLights[i].color, 1.0);

        finalColor += kd*diffuse + ks*spec;

      }

      // final color      
      out_FragColor = ka + finalColor;

    }
  </script>

    <!--
      Finally, include the script that
      runs your three.js app.
    -->

    <script src="js/app-golfball.js"></script>

  </body>

</html>