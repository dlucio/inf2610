<!DOCTYPE html>
<html>

  <head>

    <title>INF2610 - Rendering em Tempo Real: Deferred Shading</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8" />

    <link rel="icon" href="https://discoverthreejs.com/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="../js/vendor/highlight/styles/github-gist.css">
    <script src="../js/vendor/highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>    

    <link href="../styles/main.css" rel="stylesheet" type="text/css">

    <!--

      Include the main three.js script.

      The global variable THREE will be
      available for use in any scripts
      loaded after this one.

    -->

    <script src="../js/vendor/three/takahirox/three.js"></script>
    <!-- <script src="../js/vendor/three/three.js"></script> -->

    <!--
      
      Include all needed scripts.
      
      This must be included AFTER the three.js script as it
      needs to use the global THREE variable
      
    -->
    
    <script src="../js/vendor/three/WebGL.js"></script>
    <script src="../js/vendor/three/OrbitControls.js"></script>
    <script src="../js/vendor/three/dat.gui.min.js"></script>
    <script src="../js/vendor/three/GLTFLoader.js"></script>
    <script src="../js/vendor/three/MTLLoader.js"></script>
    <script src="../js/vendor/three/LoaderSupport.js"></script>
    <script src="../js/vendor/three/OBJLoader2.js"></script>
    <script src="../js/vendor/three/BufferGeometryUtils.js"></script>
    <script src="../js/vendor/three/jsm/math/SimplexNoise.js"></script>

  </head>

  <body>

    <div class="wrapper">

        <header class="header">
            <h1 class="title">Screen Space Ambient Occlusion</h1>
            <!-- <h2 class="title">Using TBN in vertex shader</h2> -->
            <div id="scene-container">
              <!-- This div will hold our scene-->
            </div>
        </header>
        <aside class="aside aside-1">
            <h2 class="title">G-Buffer Vertex Shader</h2>
          <pre>
            <code class="glsl" id="gbuffer-vertex-shader-code">
              G-BUFFER-VERTEX SHADER    
            </code>
          </pre>
        </aside>
        <aside class="aside aside-1">
          <h2 class="title">G-Buffer Fragment Shader</h2>
          <pre>
            <code class="glsl" id="gbuffer-fragment-shader-code">
              G-BUFFER-FRAGMENT SHADER
            </code>
          </pre>
        </aside>
        <aside class="aside aside-2">
            <h2 class="title">Lighting Vertex Shader</h2>
          <pre>
            <code class="glsl" id="lighting-vertex-shader-code">
              LIGHTING-VERTEX SHADER    
            </code>
          </pre>
        </aside>
        <aside class="aside aside-2">
          <h2 class="title">Lighting Fragment Shader</h2>
          <pre>
            <code class="glsl" id="lighting-fragment-shader-code">
              LIGHTING-FRAGMENT SHADER
            </code>
          </pre>
        </aside>
        <footer class="footer">
            <h4 class="title">INF2610 - Rendering em Tempo Real</h4>
        </footer>
  
    </div>

    <!-- Geometry VS and FS -->
    <script id="geometry_vs" type="x-shader/x-vertex">
      #version 300 es

      /**
        https://threejs.org/docs/index.html#api/en/renderers/webgl/WebGLProgram
        Uniforms injected by Three.js:
        - position: vertex position
        - uv: texture coordinates
        - normal: vertex normal
        - projectionMatrix: project matrix
        - normalMatrix: normal matrix
        - modelViewMatrix: model view matrix
        - cameraPosition: camera position
      */

      // Tangent generated by model loader OBJLoader2 
      attribute vec4 tangent;
      
      out vec2 vUv;     // texture coordinates
      out vec3 fragPos; // vertex position
      out vec3 vNormal; // vertex normal

      void main() 
      {
        
        // Position in view coordinates
        vec4 viewPos = modelViewMatrix * vec4(position, 1.0);
        fragPos = viewPos.xyz;

        // Just repassing the texture coordinates and vertex normals
        vUv = uv;
        vNormal = normal;

        gl_Position = projectionMatrix * viewPos;
      }
  </script>
  <script id="geometry_fs" type="x-shader/x-fragment">
    #version 300 es

    precision highp float;
    precision highp int;

    in vec2 vUv;                   // texture coordinates
    in vec3 fragPos;               // vertex position
    in vec3 vNormal;               // vertex normal
    
    // G-Buffer outputs
    layout(location=0) out vec4 gColor;     // vertex color
    layout(location=1) out vec3 gPosition;  // vertex position
    layout(location=2) out vec3 gNormal;    // vertex normal

    void main() 
    {
      // G-Buffers outputs
      gPosition = fragPos;
      gColor = vec4(0.95);
      gNormal = vNormal;
    }
  </script>

  <!-- Read G-Buffer and process SSAO -->
  <script id="ssao-vs" type="x-shader/x-vertex">
    #version 300 es

    // Texture coordinates
    out vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  </script>
  <script id="ssao-fs" type="x-shader/x-fragment">
    #version 300 es

    // Occlusion factor
    layout(location = 0) out vec4 out_FragColor;

    // Texture coordinates
    in vec2 vUv;

    uniform sampler2D gPosition;   // vertex position from G-Buffer
    uniform sampler2D gNormal;     // vertex normal from G-Buffer
    uniform sampler2D tDepth;      // depth from G-Buffer
    uniform sampler2D texNoise;    // generated noise texture 

    uniform float cameraNear;
    uniform float cameraFar;
    uniform mat4 cameraProjectionMatrix;
    uniform mat4 cameraInverseProjectionMatrix;
    
    uniform mat4 projection;
    uniform vec2 resolution;
    uniform vec3 kernel[KERNEL_SIZE];

    uniform float kernelRadius;
		uniform float minDistance;     // avoid artifacts caused by neighbour fragments with minimal depth difference
		uniform float maxDistance;     // avoid the influence of fragments which are too far away
    
    
    #include <packing>
    
    float getDepth( const in vec2 screenPosition ) {
      return texture( tDepth, screenPosition ).x;
    }
    
    float getLinearDepth( const in vec2 screenPosition ) {
      #if PERSPECTIVE_CAMERA == 1
        float fragCoordZ = texture( tDepth, screenPosition ).x;
        float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
        return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
      #else
        return texture2D( depthSampler, coord ).x;
      #endif
    }

    float getViewZ( const in float depth ) {
      #if PERSPECTIVE_CAMERA == 1
        return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
      #else
        return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
      #endif
    }

    vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
      float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
      vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
      clipPosition *= clipW; // unprojection.
      return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
    }
    
    vec3 getViewNormal( const in vec2 screenPosition ) {
      return unpackRGBToNormal( texture2D( gNormal, screenPosition ).xyz );
    }
    
    void main() {
      float depth = getDepth( vUv );
      float viewZ = getViewZ( depth );

      vec3 viewPosition = getViewPosition( vUv, depth, viewZ );
      vec3 viewNormal = getViewNormal( vUv );

      vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );
      vec3 random = texture( texNoise, vUv * noiseScale ).xyz;

      // compute matrix used to reorient a kernel vector
      vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
      vec3 binormal = cross( viewNormal, tangent );
      mat3 TBN = mat3( tangent, binormal, viewNormal );

      float occlusion = 0.0;
      for( int i = 0; i < KERNEL_SIZE; i++ ) {

        // reorient sample vector in view space
        vec3 sampleVector = TBN * kernel[i];
        
        // calculate sample point
        vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );

        // project point and calculate NDC
        vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );
        samplePointNDC /= samplePointNDC.w;

        // compute uv coordinates
        vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;

        // get linear depth from depth texture
        float realDepth = getLinearDepth( samplePointUv );
        // compute linear depth of the sample view Z value
        float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );
        float delta = sampleDepth - realDepth;

        if( delta > minDistance && delta < maxDistance ) {
          occlusion += 1.0;
        }
      }

      occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );
      out_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );
      //out_FragColor = vec4(viewNormal, 1.0);
    }
  </script>





    <!-- Write to G-Buffer -->
    <script id="gvs" type="x-shader/x-vertex">
      #version 300 es

      /**
        https://threejs.org/docs/index.html#api/en/renderers/webgl/WebGLProgram
        Uniforms injected by Three.js:
        - position: vertex position
        - uv: texture coordinates
        - normal: vertex normal
        - projectionMatrix: project matrix
        - normalMatrix: normal matrix
        - modelViewMatrix: model view matrix
        - cameraPosition: camera position
      */

      // Tangent generated by model loader OBJLoader2 
      attribute vec4 tangent;
      
      out vec2 vUv;     // texture coordinates
      out vec3 fragPos; // vertex position
      out mat3 TBN;     // Tangent Binormal Normal matrix
      out vec3 vNormal; // vertex normal

      void main() 
      {
        
        // Generating binormal vector
        vec4 binormal = normalize( vec4( cross(normal, tangent.xyz), 0.0 ) );

        // Gerenating Tangent Binormal Normal matrix
        vec3 T = normalize(vec3(modelMatrix * tangent));
        vec3 B = normalize(vec3(modelMatrix * binormal));
        vec3 N = normalize(vec3(modelMatrix * vec4(normal, 0.0)));
        TBN = ( mat3(T, B, N) );
        
        // Position in world coordinates
        fragPos = vec3( modelMatrix * vec4(position, 1.0) );

        // Just repassing the texture coordinates and vertex normals
        vUv = uv;
        vNormal = normal;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
  </script>
  <script id="gfs" type="x-shader/x-fragment">
    #version 300 es

    precision highp float;
    precision highp int;

    in vec2 vUv;                   // texture coordinates
    in vec3 fragPos;               // vertex position
    in vec3 vNormal;               // vertex normal
    in mat3 TBN;                   // Tangent Binormal Normal matrix
    
    uniform vec4 maskColor;        // mask color
    uniform sampler2D bumpTex;     // normal texture

    // G-Buffer outputs
    layout(location=0) out vec4 gColor;     // vertex color
    layout(location=1) out vec3 gNormalMap; // normal map from bump texture
    layout(location=2) out vec3 gPosition;  // vertex position
    layout(location=3) out vec3 gNormal;    // vertex normal

    void main() 
    {
      // G-Buffers outputs
      gPosition = fragPos;
      
      // Obtain normal from normal map in range [0,1]
      vec3 normalTex = texture2D(bumpTex, vUv).xyz;
      gNormalMap = normalize(-1.0 + 2.0*normalTex);
      gNormalMap = normalize( TBN * gNormalMap );
      
      // G-Buffer output for debug
      gColor = maskColor;
      gNormal = vNormal;
    }
  </script>
    
    <!-- Read G-Buffer and render to screen -->
    <script id="render-vert" type="x-shader/x-vertex">
      #version 300 es

      // Texture coordinates
      out vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
    </script>
    <script id="render-frag" type="x-shader/x-fragment">
      #version 300 es

      struct PointLight {
        vec3 color;
        vec3 position;
        float distance; 
      };

      // Point light array injected by Three.js
      uniform PointLight pointLights[NUM_POINT_LIGHTS];
      
      // Final color
      layout(location = 0) out vec4 out_FragColor;

      // Texture coordinates
      in vec2 vUv;

      uniform vec4 ka;               // ambient color from model file
      uniform vec4 kd;               // diffuse color from model file
      uniform vec4 ks;               // specular color from model file
      uniform float shi;             // shininess from model file
      uniform vec3 cameraPos;        // gbuffer camera position
      uniform int gBufferToShow;     // show saved gbuffer
      uniform bool useSpecular;      // Enable or disable specular
      uniform bool useMaskColor;     // Enable or disable mask color
      uniform vec4 maskColor;        // mask used to paint only the model
      uniform vec4 backgroundColor;  // mask used to paint only the quad

      uniform sampler2D tColor;      // vertex color
      //uniform sampler2D tNormalMap;  // normals from normal map texture
      uniform sampler2D tPosition;   // vertex position

      uniform sampler2D tNormal;     // vertex normal
      uniform sampler2D tDepth;      // depth buffer
      uniform sampler2D ssao;        // FIXME: DEFINIR

      void main() {

        out_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        
        // retrieve data from gbuffer
        vec3 Diffuse = texture(tColor, vUv).rgb;
        float AmbientOcclusion = texture(ssao, vUv).r;
        
        vec3 fragPos = texture2D(tPosition, vUv).xyz;
        vec3 normal = texture2D(tNormal, vUv).xyz;
        
        // then calculate lighting as usual
        //vec3 ambient = vec3(0.99 * Diffuse  * (AmbientOcclusion) );
        vec3 ambient = vec3( Diffuse );
        
        out_FragColor = vec4(Diffuse * AmbientOcclusion, 1.0);

        /*



        // Only for debug
        vec3 normalMapColor = abs(normal);

        // Set normal from normal map in range [0,1]
        normal = normalize(-1.0 + 2.0*normal);

        // Get vertex color that is used as a mask
        vec4 color = vec4(texture2D(tColor, vUv).rgb, 1.0);

        vec4 finalColor = backgroundColor;
        
        // Only paint model, if mask is not used
        if (color == maskColor || !useMaskColor)
        {
          finalColor = vec4(0.0, 0.0, 0.0, 1.0);

          for(int i=0; i < NUM_POINT_LIGHTS; i++)
          {
            vec3 lightPos =  pointLights[i].position;
            vec3 lightDir = normalize( lightPos - fragPos );

            // Compute lighting
            float NdotL = dot( lightDir, normal );

            // Calculate specular
            float spec = 0.0;
            if ( NdotL > 0.0 && useSpecular) {
              vec3 viewDir = normalize( cameraPos - fragPos );
              vec3 halfVector = normalize( lightDir + viewDir );
              spec = pow( max( dot( normal, halfVector ), 0.0 ), shi );
            }

            // diffuse color from light color
            float diff = max( NdotL, 0.0 );
            vec4 diffuse = diff * vec4(pointLights[i].color, 1.0);
    
            finalColor += kd*diffuse + ks*spec;
            
          }
        }

        // final color
        out_FragColor = ka + finalColor;

        // For debug: Textures from G-Buffer
        if (gBufferToShow == 1) 
        {
          // position
          out_FragColor = vec4(fragPos, 1.0);
        } 
        else if (gBufferToShow == 2) {
          // normal map
          out_FragColor = vec4(normalMapColor, 1.0);
        }
        else if (gBufferToShow == 3) {
          // vertex normal
          out_FragColor = vec4(texture2D(tNormal, vUv).rgb, 1.0);
        }
        else if (gBufferToShow == 4) {
          // vertex color
          out_FragColor = vec4(texture2D(tColor, vUv).rgb, 1.0);
        }
        else if (gBufferToShow == 5) {
          // depth
          vec4 depth = texture( tDepth, vUv ).rgba;
          depth.r = depth.r + 0.4;
          out_FragColor = vec4(depth.r, depth.r, depth.r, 1.0);
        }
        */

      }
    </script>

    <!--
      Finally, include the script that
      runs your three.js app.
    -->

    <script src="js/app-ssao.js"></script>

  </body>

</html>