<!DOCTYPE html>
<html>

  <head>

    <title>INF2610 - Rendering em Tempo Real: Deferred Shading</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8" />

    <link rel="icon" href="https://discoverthreejs.com/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="../js/vendor/highlight/styles/github-gist.css">
    <script src="../js/vendor/highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>    

    <link href="../styles/main.css" rel="stylesheet" type="text/css">

    <!--

      Include the main three.js script.

      The global variable THREE will be
      available for use in any scripts
      loaded after this one.

    -->

    <script src="../js/vendor/three/takahirox/three.js"></script>
    <!-- <script src="../js/vendor/three/three.js"></script> -->

    <!--
      
      Include all needed scripts.
      
      This must be included AFTER the three.js script as it
      needs to use the global THREE variable
      
    -->
    
    <script src="../js/vendor/three/WebGL.js"></script>
    <script src="../js/vendor/three/OrbitControls.js"></script>
    <script src="../js/vendor/three/dat.gui.min.js"></script>
    <script src="../js/vendor/three/GLTFLoader.js"></script>
    <script src="../js/vendor/three/MTLLoader.js"></script>
    <script src="../js/vendor/three/LoaderSupport.js"></script>
    <script src="../js/vendor/three/OBJLoader2.js"></script>
    <script src="../js/vendor/three/BufferGeometryUtils.js"></script>
    <script src="../js/vendor/three/jsm/math/SimplexNoise.js"></script>

  </head>

  <body>

    <div class="wrapper">

        <header class="header">
            <h1 class="title">Screen Space Ambient Occlusion</h1>
            <!-- <h2 class="title">Using TBN in vertex shader</h2> -->
            <div id="scene-container">
              <!-- This div will hold our scene-->
            </div>
        </header>
        <aside class="aside aside-1">
            <h2 class="title">G-Buffer Vertex Shader</h2>
          <pre>
            <code class="glsl" id="gbuffer-vertex-shader-code">
              G-BUFFER-VERTEX SHADER    
            </code>
          </pre>
        </aside>
        <aside class="aside aside-1">
          <h2 class="title">G-Buffer Fragment Shader</h2>
          <pre>
            <code class="glsl" id="gbuffer-fragment-shader-code">
              G-BUFFER-FRAGMENT SHADER
            </code>
          </pre>
        </aside>
        <aside class="aside aside-2">
            <h2 class="title">Lighting Vertex Shader</h2>
          <pre>
            <code class="glsl" id="lighting-vertex-shader-code">
              LIGHTING-VERTEX SHADER    
            </code>
          </pre>
        </aside>
        <aside class="aside aside-2">
          <h2 class="title">Lighting Fragment Shader</h2>
          <pre>
            <code class="glsl" id="lighting-fragment-shader-code">
              LIGHTING-FRAGMENT SHADER
            </code>
          </pre>
        </aside>
        <footer class="footer">
            <h4 class="title">INF2610 - Rendering em Tempo Real</h4>
        </footer>
  
    </div>

    <!-- Geometry VS and FS -->
    <script id="geometry_vs" type="x-shader/x-vertex">
      #version 300 es

      /**
        https://threejs.org/docs/index.html#api/en/renderers/webgl/WebGLProgram
        Uniforms injected by Three.js:
        - position: vertex position
        - uv: texture coordinates
        - normal: vertex normal
        - projectionMatrix: project matrix
        - normalMatrix: normal matrix
        - modelViewMatrix: model view matrix
        - cameraPosition: camera position
      */

      // Tangent generated by model loader OBJLoader2 
      attribute vec4 tangent;
      
      out vec2 vUv;     // texture coordinates
      out vec3 fragPos; // vertex position
      out vec3 vNormal; // vertex normal

      void main() 
      {
        
        // Position in view coordinates
        vec4 viewPos = modelViewMatrix * vec4(position, 1.0);
        fragPos = viewPos.xyz;

        // Just repassing the texture coordinates and vertex normals
        vUv = uv;
        vNormal = normal;

        gl_Position = projectionMatrix * viewPos;
      }
  </script>
  <script id="geometry_fs" type="x-shader/x-fragment">
    #version 300 es

    precision highp float;
    precision highp int;

    in vec2 vUv;                   // texture coordinates
    in vec3 fragPos;               // vertex position
    in vec3 vNormal;               // vertex normal
    
    // G-Buffer outputs
    layout(location=0) out vec4 gColor;     // vertex color
    layout(location=1) out vec3 gPosition;  // vertex position
    layout(location=2) out vec3 gNormal;    // vertex normal

    void main() 
    {
      // G-Buffers outputs
      gPosition = fragPos;
      gColor = vec4(0.95); //maskColor;
      gNormal = vNormal;
    }
  </script>

  <!-- Read G-Buffer and process SSAO -->
  <script id="ssao-vs" type="x-shader/x-vertex">
    #version 300 es

    // Texture coordinates
    out vec2 vUv;
    out mat4 projection;

    void main() {

      vUv = uv;
      gl_Position = vec4( position, 1.0 );

    }
  </script>
  <script id="ssao-fs" type="x-shader/x-fragment">
    #version 300 es

    // Occlusion factor
    layout(location = 0) out vec4 out_FragColor;

    // Texture coordinates
    in vec2 vUv;
    in mat4 projection;

    uniform sampler2D gPosition;   // vertex position from G-Buffer
    uniform sampler2D gNormal;     // vertex normal from G-Buffer
    uniform sampler2D texNoise;    // generated noise texture 

    
    uniform vec3 samples[32];
    
    // parameters (you'd probably want to use them as uniforms to more easily tweak the effect)
    int kernelSize = 32;
    float radius = 0.5;
    float bias = 0.025;
    
    // tile noise texture over screen based on screen dimensions divided by noise size
    const vec2 noiseScale = vec2(1280.0/4.0, 720.0/4.0); 
    
    void main() {
      
      vec3 fragPos = texture2D(gPosition, vUv).xyz;
      vec3 normal = normalize( texture2D(gNormal, vUv).xyz );
      vec3 randomVec = normalize( texture(texNoise, vUv*noiseScale).xyz );

      // create TBN change-of-basis matrix: from tangent-space to view-space
      vec3 tangent = normalize( randomVec - normal * dot(randomVec, normal) );
      vec3 binormal = cross(normal, tangent);
      mat3 TBN = mat3(tangent, binormal, normal);
      
      // iterate over the sample kernel and calculate occlusion factor
      float occlusion = 0.0;
      for(int i = 0; i < kernelSize; ++i)
      {
        // get sample position
        vec3 Sample = TBN * samples[i];  // from tangent to view-space
        Sample = fragPos + Sample * radius;
        
        // project sample position (to sample texture) (to get position on screen/texture)
        vec4 offset = vec4(Sample, 1.0);
        offset = projection * offset; // from view to clip-space
        offset.xyz /= offset.w;
        offset.xyz = offset.xyz * 0.5 + 0.5; // transform to range 0.0 - 1.0
        
        // get sample depth
        float sampleDepth = texture( gPosition, offset.xy ).z; // get depth value of kernel sample
        
        // get check & accumulate
        float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth));
        occlusion += ( sampleDepth >= Sample.z + bias ? 1.0 : 0.0 ) * rangeCheck;
      }
      occlusion  = 1.0 - (occlusion - float(kernelSize)) ;

      out_FragColor = vec4(occlusion);

    }
  </script>





    <!-- Write to G-Buffer -->
    <script id="gvs" type="x-shader/x-vertex">
      #version 300 es

      /**
        https://threejs.org/docs/index.html#api/en/renderers/webgl/WebGLProgram
        Uniforms injected by Three.js:
        - position: vertex position
        - uv: texture coordinates
        - normal: vertex normal
        - projectionMatrix: project matrix
        - normalMatrix: normal matrix
        - modelViewMatrix: model view matrix
        - cameraPosition: camera position
      */

      // Tangent generated by model loader OBJLoader2 
      attribute vec4 tangent;
      
      out vec2 vUv;     // texture coordinates
      out vec3 fragPos; // vertex position
      out mat3 TBN;     // Tangent Binormal Normal matrix
      out vec3 vNormal; // vertex normal

      void main() 
      {
        
        // Generating binormal vector
        vec4 binormal = normalize( vec4( cross(normal, tangent.xyz), 0.0 ) );

        // Gerenating Tangent Binormal Normal matrix
        vec3 T = normalize(vec3(modelMatrix * tangent));
        vec3 B = normalize(vec3(modelMatrix * binormal));
        vec3 N = normalize(vec3(modelMatrix * vec4(normal, 0.0)));
        TBN = ( mat3(T, B, N) );
        
        // Position in world coordinates
        fragPos = vec3( modelMatrix * vec4(position, 1.0) );

        // Just repassing the texture coordinates and vertex normals
        vUv = uv;
        vNormal = normal;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
  </script>
  <script id="gfs" type="x-shader/x-fragment">
    #version 300 es

    precision highp float;
    precision highp int;

    in vec2 vUv;                   // texture coordinates
    in vec3 fragPos;               // vertex position
    in vec3 vNormal;               // vertex normal
    in mat3 TBN;                   // Tangent Binormal Normal matrix
    
    uniform vec4 maskColor;        // mask color
    uniform sampler2D bumpTex;     // normal texture

    // G-Buffer outputs
    layout(location=0) out vec4 gColor;     // vertex color
    layout(location=1) out vec3 gNormalMap; // normal map from bump texture
    layout(location=2) out vec3 gPosition;  // vertex position
    layout(location=3) out vec3 gNormal;    // vertex normal

    void main() 
    {
      // G-Buffers outputs
      gPosition = fragPos;
      
      // Obtain normal from normal map in range [0,1]
      vec3 normalTex = texture2D(bumpTex, vUv).xyz;
      gNormalMap = normalize(-1.0 + 2.0*normalTex);
      gNormalMap = normalize( TBN * gNormalMap );
      
      // G-Buffer output for debug
      gColor = maskColor;
      gNormal = vNormal;
    }
  </script>
    
    <!-- Read G-Buffer and render to screen -->
    <script id="render-vert" type="x-shader/x-vertex">
      #version 300 es

      // Texture coordinates
      out vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
    </script>
    <script id="render-frag" type="x-shader/x-fragment">
      #version 300 es

      struct PointLight {
        vec3 color;
        vec3 position;
        float distance; 
      };

      // Point light array injected by Three.js
      uniform PointLight pointLights[NUM_POINT_LIGHTS];
      
      // Final color
      layout(location = 0) out vec4 out_FragColor;

      // Texture coordinates
      in vec2 vUv;

      uniform vec4 ka;               // ambient color from model file
      uniform vec4 kd;               // diffuse color from model file
      uniform vec4 ks;               // specular color from model file
      uniform float shi;             // shininess from model file
      uniform vec3 cameraPos;        // gbuffer camera position
      uniform int gBufferToShow;     // show saved gbuffer
      uniform bool useSpecular;      // Enable or disable specular
      uniform bool useMaskColor;     // Enable or disable mask color
      uniform vec4 maskColor;        // mask used to paint only the model
      uniform vec4 backgroundColor;  // mask used to paint only the quad

      uniform sampler2D tColor;      // vertex color
      uniform sampler2D tNormalMap;  // normals from normal map texture
      uniform sampler2D tPosition;   // vertex position

      uniform sampler2D tNormal;     // vertex normal
      uniform sampler2D tDepth;      // depth buffer
      uniform sampler2D ssao;        // FIXME: DEFINIR

      void main() {

        vec3 fragPos = texture2D(tPosition, vUv).xyz;
        vec3 normal = texture2D(tNormalMap, vUv).xyz;

        // Only for debug
        vec3 normalMapColor = abs(normal);

        // Set normal from normal map in range [0,1]
        normal = normalize(-1.0 + 2.0*normal);

        // Get vertex color that is used as a mask
        vec4 color = vec4(texture2D(tColor, vUv).rgb, 1.0);

        vec4 finalColor = backgroundColor;
        
        // Only paint model, if mask is not used
        if (color == maskColor || !useMaskColor)
        {
          finalColor = vec4(0.0, 0.0, 0.0, 1.0);

          for(int i=0; i < NUM_POINT_LIGHTS; i++)
          {
            vec3 lightPos =  pointLights[i].position;
            vec3 lightDir = normalize( lightPos - fragPos );

            // Compute lighting
            float NdotL = dot( lightDir, normal );

            // Calculate specular
            float spec = 0.0;
            if ( NdotL > 0.0 && useSpecular) {
              vec3 viewDir = normalize( cameraPos - fragPos );
              vec3 halfVector = normalize( lightDir + viewDir );
              spec = pow( max( dot( normal, halfVector ), 0.0 ), shi );
            }

            // diffuse color from light color
            float diff = max( NdotL, 0.0 );
            vec4 diffuse = diff * vec4(pointLights[i].color, 1.0);
    
            finalColor += kd*diffuse + ks*spec;
            
          }
        }

        // final color
        out_FragColor = ka + finalColor;

        // For debug: Textures from G-Buffer
        if (gBufferToShow == 1) 
        {
          // position
          out_FragColor = vec4(fragPos, 1.0);
        } 
        else if (gBufferToShow == 2) {
          // normal map
          out_FragColor = vec4(normalMapColor, 1.0);
        }
        else if (gBufferToShow == 3) {
          // vertex normal
          out_FragColor = vec4(texture2D(tNormal, vUv).rgb, 1.0);
        }
        else if (gBufferToShow == 4) {
          // vertex color
          out_FragColor = vec4(texture2D(tColor, vUv).rgb, 1.0);
        }
        else if (gBufferToShow == 5) {
          // depth
          vec4 depth = texture( tDepth, vUv ).rgba;
          depth.r = depth.r + 0.4;
          out_FragColor = vec4(depth.r, depth.r, depth.r, 1.0);
        }

      }
    </script>

    <!--
      Finally, include the script that
      runs your three.js app.
    -->

    <script src="js/app-ssao.js"></script>

  </body>

</html>