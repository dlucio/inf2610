<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>reveal.js</title>

        <link rel="stylesheet" href="css/reset.css">
        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/monokai.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
                    <h3> Screen Space Ambient Occlusion </h3>
                    <p>Djalma Lúcio</p>
                    <p> <small>INF2610 2019.1</small></p>
                </section>

                <!-- INTRODUÇÃO -->
                <section>

                    <section>
                        <h3>Introdução</h3>
                    </section>
                    
                    <!-- AO -->
                    <section>
                        <h3>Luz Ambiente</h3>
                        <p style="text-align: justify">
                            A iluminação ambiente é uma luz fixa e constante que adicionamos 
                            à iluminação geral de uma cena para simular a dispersão da luz.
                        </p>
                        <p style="text-align: justify">
                            Na realidade, a luz se espalha em todos os tipos de direções com intensidades variadas, 
                            de modo que as partes indiretamente iluminadas de uma cena também devem ter intensidades variadas, 
                            em vez de um componente ambiente constante.
                        </p>
                    </section>
                    <section>
                        <h3>Ambient Occlusion (AO)</h3>
                        <p style="text-align: justify">
                            Um tipo de aproximação de iluminação indireta é a <b>Ambient Occlusion</b>, 
                            que tenta aproximar a iluminação indireta, escurecendo vincos, 
                            buracos e superfícies próximos uns dos outros.
                        </p>
                    </section>
                    
                    <!-- SSAO -->
                    <section>
                        <h3>Screen Space Ambient Occlusion</h3>
                        <h3>( SSAO )</h3>
                        <p style="text-align: justify">
                            SSAO é uma aproximação de AO implementada em GPU onde é usado o depth-buffer 
                            para testar a oclusão de uma amostra de pontos. 
                        </p>
                        <p style="text-align: justify">
                            A técnica SSAO foi desenvolvida pela CryTek para ser utilizada em seu jogo Crysis e em sua engine.
                        </p>
                    </section>
                    <section>
                        <h3>Screen Space Ambient Occlusion</h3>
                        <div>
                            <img src="images/ssao_algoritmo_notas_aula.png" width="756" height="515" >
                        </div>
                        <div>
                           <small style="font-size: 10px !important;">
                            Fonte: http://webserver2.tecgraf.puc-rio.br/~celes/docs/inf2610/AO.pdf
                        </small> 
                        </div>
                    </section>
                    <section>
                        <h3>Screen Space Ambient Occlusion</h3>
                        <div>
                            <img width="296" height="356" data-src="images/with_without_ssao.gif">
                        </div>
                        <div>
                            <small style="font-size: 10px !important;">
                                Fonte: https://learnopengl.com/Advanced-Lighting/SSAO
                            </small>
                        </div>
					</section>
                </section>

                <!-- DESCRIÇÃO DA TÉCNICA -->
                <section>
                    <section>
                        <h3>Descrição da Técnica</h3>
                        <ul>
                            <li>Passo 1: Depth e Normais</li>
                            <li>Passo 2: SSAO</li>
                            <li>Passo 3: Blur da SSAO</li>
                            <li>Passo 4: Iluminação</li>
                        </ul>
                    </section>

                    <section>
                        <h3>Vertex Shader</h3>
                        <p>Comum aos passos</p>
                        <pre>
                            <!-- <code class="glsl" data-trim data-line-numbers="4,8-9"> -->
                            <code class="glsl" data-trim data-line-numbers>
                                #version 300 es

                                // Texture coordinates
                                out vec2 vUv;

                                void main() {

                                  vUv = uv;
                                  vec4 fragPos = modelViewMatrix * vec4( position, 1.0 );
                                  gl_Position =  projectionMatrix * fragPos;

                                }
                            
                            </code>
                        </pre>
                    </section>
                    
                    <!-- PASSO 1 -->
                    <section>
                        <h3>Passo 1: Depth e Normais</h3>
                        <p>Obtendo os valores de profundidade e das normais.</p>
                        <pre>
                            <code class="javascript" data-trim data-line-numbers="4,13,23-25,33,36">
                                ...
                                // scene render target with depth buffer
                                let depthTexture = new DepthTexture();
                                depthTexture.type = THREE.FloatType; // WebGL1 UnsignedShortType
                                depthTexture.minFilter = NearestFilter;
                                depthTexture.maxFilter = NearestFilter;
                            
                                this.sceneRenderTarget = new WebGLRenderTarget( this.width, this.height, {
                                    minFilter: LinearFilter,
                                    magFilter: LinearFilter,
                                    format: RGBAFormat,
                                    depthTexture: depthTexture,
                                    depthBuffer: true
                                } );
                            
                                // normal render target
                                this.normalRenderTarget = new WebGLRenderTarget( this.width, this.height, {
                                    minFilter: NearestFilter,
                                    magFilter: NearestFilter,
                                    format: RGBAFormat
                                } );

                                // normal material
                                this.normalMaterial = new MeshNormalMaterial();
                                this.normalMaterial.blending = NoBlending;


                                ...
                                
                                // render scene and depth
                                renderer.setRenderTarget( this.sceneRenderTarget );
                                renderer.clear();
                                renderer.render( this.scene, this.camera );
                        
                                // render normals
                                this.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, clearColor, clearAlpha );
                                ...
                            </code>
                        </pre>
                    </section>

                    <!-- PASSO 2 -->
                    <section>
                        <h3>Passo 2: SSAO</h3>
                        <ul>
                            <li>Preparação</li>
                            <ul>
                                <li>Gerando o kernel</li>
                                <li>Gerando a textura de rotação</li>
                            </ul>
                            <li>Shader da SSAO</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Gerando o kernel</h3>
                        <pre>
                            <code class="javascript" data-trim data-line-numbers="">
                                function generateSampleKernel() {

                                    var kernelSize = this.kernelSize;
                                    var kernel = this.kernel;
                            
                                    for ( var i = 0; i < kernelSize; i ++ ) {
                            
                                        var sample = new Vector3();
                                        sample.x = ( Math.random() * 2 ) - 1;
                                        sample.y = ( Math.random() * 2 ) - 1;
                                        sample.z = Math.random();
                            
                                        sample.normalize();
                            
                                        var scale = i / kernelSize;
                                        scale = _Math.lerp( 0.1, 1, scale * scale );
                                        sample.multiplyScalar( scale );
                            
                                        kernel.push( sample );
                            
                                    }
                                }
                            </code>
                        </pre>
                    </section>
                    <section>
                        <h3>Gerando a textura de rotação</h3>
                        <pre>
                            <code class="javascript" data-trim data-line-numbers>
                                    function generateRandomKernelRotations() {

                                        var width = 4, height = 4;
                                        var simplex = new SimplexNoise();
                                
                                        var size = width * height;
                                        var data = new Float32Array( size * 4 );
                                
                                        for ( var i = 0; i < size; i ++ ) {
                                
                                            var stride = i * 4;
                                
                                            var x = ( Math.random() * 2 ) - 1;
                                            var y = ( Math.random() * 2 ) - 1;
                                            var z = 0;
                                
                                            var noise = simplex.noise3d( x, y, z );
                                
                                            data[ stride ] = noise;
                                            data[ stride + 1 ] = noise;
                                            data[ stride + 2 ] = noise;
                                            data[ stride + 3 ] = 1;
                                
                                        }
                                
                                        this.noiseTexture = new DataTexture( data, width, height, RGBAFormat, FloatType );
                                        this.noiseTexture.wrapS = RepeatWrapping;
                                        this.noiseTexture.wrapT = RepeatWrapping;
                                        this.noiseTexture.needsUpdate = true;
                                
                                    }
                            </code>
                        </pre>
                    </section>
                    <section>
                        <h3>SSAO Shader</h3>
                        <pre>
                            <code class="glsl" data-trim data-line-numbers>
                            #version 300 es
                            layout(location = 0) out vec4 out_FragColor;
                                
                            uniform sampler2D tDiffuse;
                            uniform sampler2D tNormal;
                            uniform sampler2D tDepth;
                            uniform sampler2D tNoise;
                                
                            uniform vec3 kernel[ KERNEL_SIZE ];
                                
                            uniform vec2 resolution;
                                
                            uniform float cameraNear;
                            uniform float cameraFar;
                            uniform mat4 cameraProjectionMatrix;
                            uniform mat4 cameraInverseProjectionMatrix;

                            uniform float kernelRadius;
                            uniform float minDistance;
                            uniform float maxDistance;
                            
                            in vec2 vUv;
                                
                            #include <packing>
                            
                            float getDepth( const in vec2 screenPosition ) {
                                
                                return texture2D( tDepth, screenPosition ).x;
                                
                            }
                            
                            float getLinearDepth( const in vec2 screenPosition ) {
                                
                                #if PERSPECTIVE_CAMERA == 1
                                
                                float fragCoordZ = texture( tDepth, screenPosition ).x;
                                float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
                                return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
                                
                                #else
                                
                                return texture2D( depthSampler, coord ).x;
                                
                                #endif
                                
                            }
                            
                            float getViewZ( const in float depth ) {
                                
                                #if PERSPECTIVE_CAMERA == 1
                                
                                return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
                                
                                #else
                                
                                return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
                                
                                #endif
                                
                            }
                            
                            vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
                                
                                float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
                                vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
                                clipPosition *= clipW; // unprojection.
                                
                                return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
                            }
                            
                            vec3 getViewNormal( const in vec2 screenPosition ) {
                                
                                return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
                                
                            }
                            
                            void main() {
                                
                                float depth = getDepth( vUv );
                                float viewZ = getViewZ( depth );
                                
                                vec3 viewPosition = getViewPosition( vUv, depth, viewZ );
                                vec3 viewNormal = getViewNormal( vUv );
                                
                                vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );
                                vec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;
                                
                                // compute matrix (TBN) used to reorient a kernel vector
                                vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
                                vec3 bitangent = cross( viewNormal, tangent );
                                mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );
                                
                                float occlusion = 0.0;
                                
                                for ( int i = 0; i < KERNEL_SIZE; i ++ ) { 
                                    // reorient sample vector in view space
                                    vec3 sampleVector = kernelMatrix * kernel[ i ];

                                    // calculate sample point
                                    vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); 

                                    // project point and calculate NDC
                                    vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );
                                    samplePointNDC /= samplePointNDC.w;

                                    // compute uv coordinates
                                    vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;
                                    
                                    // get linear depth from depth texture
                                    float realDepth = getLinearDepth( samplePointUv );

                                    // compute linear depth of the sample view Z value
                                    float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );
                                    
                                    float delta = sampleDepth - realDepth;

                                    // if fragment is before sample point, increase occlusion
                                    if ( delta > minDistance && delta < maxDistance ) { 
                                        occlusion += 1.0;
                                    }
                                }
                                occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );
                                out_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );
                            }

                            </code>
                        </pre>
                    </section>

                    <!-- PASSO 3 -->
                    <section>
                        <h3>Passo 3: Blur da SSAO</h3>
                        <p>Fragment Shader</p>
                        <pre>
                            <code class="glsl" data-trim data-line-numbers>
                                #version 300 es

                                // ssao blured
                                layout(location = 0) out vec4 out_FragColor;

                                // Texture coordinates
                                in vec2 vUv;

                                // ssao
                                uniform sampler2D tDiffuse;
                                uniform vec2 resolution;

                                void main() {

                                    vec2 texelSize = (1.0 / resolution );
                                    float result = 0.0;

                                    for( int i = -2; i <= 2; i++ ) {
                                        for( int j = -2; j <= 2; j++ ) {
                                        vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;
                                        result += texture( tDiffuse, vUv + offset ).r;
                                        }
                                    }

                                    out_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );
                                }
                            </code>
                        </pre>
                    </section>

                    <!-- PASSO 4 -->
                    <section>
                        <h3>Passo 4: Iluminação</h3>
                        <h5>Phong</h5>
                    </section>

                </section>
                
                <!-- RESULTADOS -->
                <section>
                    <h3>Resultados</h3>
                </section>
                <!-- EXECUÇÃO DO PROGRAMA -->
                <section>
                    <!-- <h3>TODO: Habilitar o programa</h3> -->
                    <section  data-background-iframe="../ssao/ssao.html" data-background-interactive></section>
                </section>

                <section>
                    <h3>Conclusão</h3>
                    <p style="text-align: justify"> 
                        É possível fazer renderização NPR interessante
                        em tempo real e a um custo aceitável no uso da memória,
                        usando somente SSAO e um modelo simples de iluminação.
                    </p>
                    <p style="text-align: justify"> 
                        A continuidade da pesquisa será através da implementação 
                        de um algoritmo de outline para a gerar uma renderização mais próxima do estilo cartoon.
                        Além de alguns testes com outros algoritmos de ambient occlusion.
                    </p>
                </section>

            </div>
        </div>

        <script src="js/reveal.js"></script>

        <script>
            // More info about config & dependencies:
            // - https://github.com/hakimel/reveal.js#configuration
            // - https://github.com/hakimel/reveal.js#dependencies
            Reveal.initialize({
                dependencies: [
                    { src: 'plugin/markdown/marked.js' },
                    { src: 'plugin/markdown/markdown.js' },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: 'plugin/highlight/highlight.js', async: true }
                ]
            });
        </script>
    </body>
</html>
